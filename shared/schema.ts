import { pgTable, text, serial, integer, timestamp, boolean, jsonb, uuid } from "drizzle-orm/pg-core"; // Added uuid
import { relations } from "drizzle-orm"; // For relationships
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Profiles table linked to Supabase Auth users
export const profiles = pgTable("profiles", {
  id: uuid("id").primaryKey(), // References Supabase auth.users.id - constraint handled at DB level
  username: text("username").unique(),
  fullName: text("full_name"), // Using snake_case to match database column
  role: text("role").default('user').notNull(), // e.g., 'admin', 'trainer', 'marketing', 'comercial'
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  // Add other public profile fields here if needed in the future
});

export const insertProfileSchema = createInsertSchema(profiles);
export type InsertProfile = z.infer<typeof insertProfileSchema>;
export type Profile = typeof profiles.$inferSelect;

// User type combining Profile with auth data
export type User = Profile & { email?: string }; // email can be added from authUser on client
export type InsertUser = InsertProfile & { email: string, password?: string }; // For user creation forms


// Tabela de treinadores/professores
export const trainers = pgTable("trainers", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  specialties: text("specialties").array(),
  calendarId: text("calendar_id"), // ID do calendário no Google Calendar
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTrainerSchema = createInsertSchema(trainers).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const trainerValidationSchema = insertTrainerSchema.extend({
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().optional(),
  specialties: z.array(z.string()).optional(),
  calendarId: z.string().optional(),
  active: z.boolean().optional(),
});

export type InsertTrainer = z.infer<typeof insertTrainerSchema>;
export type Trainer = typeof trainers.$inferSelect;

// Tabela de alunos (expandindo leads com status "Aluno")
export const students = pgTable("students", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").references(() => leads.id), // Referência ao lead correspondente
  address: text("address"),
  preferences: text("preferences"),
  source: text("source").notNull(), // "Favale" ou "Pink"
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertStudentSchema = createInsertSchema(students).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const studentValidationSchema = insertStudentSchema.extend({
  leadId: z.number().int().positive("ID do lead inválido"),
  address: z.string().optional(),
  preferences: z.string().optional(),
  source: z.string().min(1, "A origem é obrigatória"),
  active: z.boolean().optional(),
});

export type InsertStudent = z.infer<typeof insertStudentSchema>;
export type Student = typeof students.$inferSelect;

// Lead schema
export const leads = pgTable("leads", {
  id: serial("id").primaryKey(),
  entryDate: timestamp("entry_date").defaultNow().notNull(),
  name: text("name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  state: text("state").notNull(),
  campaign: text("campaign").notNull(),
  tags: text("tags").array().notNull(),
  source: text("source").notNull(), // "Favale" or "Pink"
  status: text("status").notNull(), // "Lead" or "Aluno"
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Criar um schema base para inserção de leads, omitindo campos autoincrementais/autogenerated
export const baseInsertLeadSchema = createInsertSchema(leads).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Schema usado para inserção no banco de dados, aceita Date ou string ISO
export const insertLeadSchema = baseInsertLeadSchema.extend({
  entryDate: z.union([
    z.string(),
    z.date()
  ]).optional(),
});

export const leadValidationSchema = insertLeadSchema.extend({
  entryDate: z.union([
    z.string().transform(val => {
      try {
        // Formatar a data se estiver no padrão DD/MM/YYYY (formato brasileiro)
        if (/^\d{2}\/\d{2}\/\d{4}$/.test(val)) {
          const [day, month, year] = val.split('/');
          return `${year}-${month}-${day}`;
        }
        // Outros formatos
        return val;
      } catch (e) {
        return val;
      }
    }).refine(value => !isNaN(Date.parse(value)), {
      message: "Data de entrada precisa ser uma data válida"
    }),
    z.date()
  ]),
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().min(1, "O telefone é obrigatório"),
  state: z.string().min(1, "O estado é obrigatório"),
  campaign: z.string().default("Importação em Lote"),
  source: z.string().min(1, "A origem é obrigatória"),
  status: z.string().min(1, "O status é obrigatório"),
});

export type InsertLead = z.infer<typeof insertLeadSchema>;
export type Lead = typeof leads.$inferSelect;

// Tabela de sessões de treinamento
export const sessions = pgTable("sessions", {
  id: serial("id").primaryKey(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  studentId: integer("student_id").references(() => students.id).notNull(),
  trainerId: integer("trainer_id").references(() => trainers.id).notNull(),
  location: text("location").notNull(), // Endereço do treino
  notes: text("notes"),
  status: text("status").default("agendado").notNull(), // agendado, concluído, cancelado, remarcado
  source: text("source").notNull(), // "Favale" ou "Pink"
  googleEventId: text("google_event_id"), // ID do evento no Google Calendar
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertSessionSchema = createInsertSchema(sessions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const sessionBaseValidationSchema = insertSessionSchema.extend({
  startTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de início precisa ser uma data válida"
  }),
  endTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de término precisa ser uma data válida"
  }),
  studentId: z.number().int().positive("ID do aluno inválido"),
  trainerId: z.number().int().positive("ID do professor inválido"),
  location: z.string().min(1, "O local é obrigatório"),
  notes: z.string().optional(),
  status: z.string().min(1, "O status é obrigatório"),
  source: z.string().min(1, "A origem é obrigatória"),
  googleEventId: z.string().optional(),
});

// Validação adicional para a criação de sessões
export const sessionValidationSchema = sessionBaseValidationSchema.refine(
  data => {
    // Verifica se a data de término é posterior à data de início
    const startTime = new Date(data.startTime instanceof Date ? data.startTime : data.startTime);
    const endTime = new Date(data.endTime instanceof Date ? data.endTime : data.endTime);
    return endTime > startTime;
  },
  {
    message: "O horário de término deve ser posterior ao horário de início",
    path: ["endTime"],
  }
);

export type InsertSession = z.infer<typeof insertSessionSchema>;
export type Session = typeof sessions.$inferSelect;

// Tabela de histórico de alterações em sessões
export const sessionHistory = pgTable("session_history", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").references(() => sessions.id).notNull(),
  changedAt: timestamp("changed_at").defaultNow().notNull(),
  changeType: text("change_type").notNull(), // created, updated, cancelled, rescheduled
  userId: uuid("user_id").references(() => profiles.id), // Changed to uuid to reference profiles.id (which references auth.users.id)
  oldValue: jsonb("old_value"), // Valor anterior (para campos alterados)
  newValue: jsonb("new_value"), // Novo valor
});

export const insertSessionHistorySchema = createInsertSchema(sessionHistory).omit({
  id: true,
});

export type InsertSessionHistory = z.infer<typeof insertSessionHistorySchema>;
export type SessionHistory = typeof sessionHistory.$inferSelect;

// WhatsApp mensagens
export const whatsappMessages = pgTable("whatsapp_messages", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").references(() => leads.id, { onDelete: 'cascade' }).notNull(), // Added onDelete cascade
  direction: text("direction").notNull(), // "incoming" ou "outgoing"
  content: text("content").notNull(),
  status: text("status").notNull(), // "sent", "delivered", "read", "failed"
  timestamp: timestamp("timestamp").defaultNow().notNull(),
  mediaUrl: text("media_url"), // URL opcional para mídia (imagens, áudio, etc.)
  mediaType: text("media_type"), // Tipo de mídia (image, audio, video, document)
  messageId: text("message_id"), // ID da mensagem na API do WhatsApp
});

export const insertWhatsappMessageSchema = createInsertSchema(whatsappMessages).omit({
  id: true,
});

export const whatsappMessageValidationSchema = insertWhatsappMessageSchema.extend({
  leadId: z.number().int().positive("ID do lead inválido"),
  direction: z.enum(["incoming", "outgoing"], {
    errorMap: () => ({ message: "Direção deve ser 'incoming' ou 'outgoing'" })
  }),
  content: z.string().min(1, "O conteúdo da mensagem é obrigatório"),
  status: z.enum(["pending", "sent", "delivered", "read", "failed"], {
    errorMap: () => ({ message: "Status inválido" })
  }),
  mediaUrl: z.string().url("URL de mídia inválida").optional(),
  mediaType: z.enum(["image", "audio", "video", "document"], {
    errorMap: () => ({ message: "Tipo de mídia inválido" })
  }).optional(),
  messageId: z.string().optional(),
});

export type InsertWhatsappMessage = z.infer<typeof insertWhatsappMessageSchema>;
export type WhatsappMessage = typeof whatsappMessages.$inferSelect;

// Tabela de tarefas
export const tasks = pgTable("tasks", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  // Assuming assignedById and assignedToId will reference the UUID from auth.users (profiles.id)
  assignedById: uuid("assigned_by_id").references(() => profiles.id).notNull(),
  assignedToId: uuid("assigned_to_id").references(() => profiles.id).notNull(),
  dueDate: timestamp("due_date"),
  priority: text("priority").default("medium").notNull(), // low, medium, high
  status: text("status").default("pending").notNull(), // pending, in_progress, completed, cancelled
  relatedLeadId: integer("related_lead_id").references(() => leads.id, { onDelete: 'set null' }), // Keep relation, set null on lead delete
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTaskSchema = createInsertSchema(tasks).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Update validation schema to expect string UUIDs for user IDs
export const taskValidationSchema = insertTaskSchema.extend({
  title: z.string().min(1, "O título é obrigatório"),
  description: z.string().optional().nullable(), // Allow null
  assignedById: z.string().uuid("ID do usuário que atribuiu a tarefa inválido"), // Expect UUID string
  assignedToId: z.string().uuid("ID do usuário atribuído inválido"), // Expect UUID string
  dueDate: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    if (arg === null || arg === undefined) return arg;
    return undefined;
  }, z.union([
    z.string().datetime({ message: "Data de vencimento precisa ser uma data válida." }).transform(val => new Date(val).toISOString()), // Store as ISO string
    z.date().transform(d => d.toISOString()) // Store as ISO string
  ])).optional().nullable().refine(dateStr => dateStr ? !isNaN(Date.parse(dateStr)) : true, { // Validate the ISO string
    message: "Data de vencimento precisa ser uma data válida ou estar vazia"
  }),
  priority: z.enum(["low", "medium", "high"]),
  status: z.enum(["backlog", "pending", "in_progress", "completed", "cancelled"]),
  relatedLeadId: z.number().int().positive("ID do lead inválido").optional().nullable(), // Allow null
});

export type InsertTask = z.infer<typeof insertTaskSchema>;
export type Task = typeof tasks.$inferSelect;

// Tabela de comentários em tarefas
export const taskComments = pgTable("task_comments", {
  id: serial("id").primaryKey(),
  taskId: integer("task_id").references(() => tasks.id, { onDelete: 'cascade' }).notNull(), // Added onDelete cascade
  userId: uuid("user_id").references(() => profiles.id).notNull(), // Changed to uuid to reference profiles.id
  content: text("content").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTaskCommentSchema = createInsertSchema(taskComments).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Update validation schema for task comments
export const taskCommentValidationSchema = insertTaskCommentSchema.extend({
  taskId: z.number().int().positive("ID da tarefa inválido"),
  userId: z.string().uuid("ID do usuário inválido"), // Expect UUID string
  content: z.string().min(1, "O conteúdo é obrigatório"),
});

export type InsertTaskComment = z.infer<typeof insertTaskCommentSchema>;
export type TaskComment = typeof taskComments.$inferSelect;

// Tabela de configurações do WhatsApp/Evolution API
export const whatsappSettingsTable = pgTable("whatsapp_settings", { // Renamed to avoid conflict if a type 'WhatsappSettings' is defined
  id: serial("id").primaryKey(),
  apiUrl: text("api_url").notNull(),
  apiToken: text("api_token").notNull(), // Consider encrypting this if stored in DB
  apiInstance: text("api_instance").notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertWhatsappSettingsSchema = createInsertSchema(whatsappSettingsTable).omit({
  id: true,
  updatedAt: true,
});

export type InsertWhatsappSettings = z.infer<typeof insertWhatsappSettingsSchema>;
export type WhatsappSettings = typeof whatsappSettingsTable.$inferSelect; // Use the renamed table

// --- New Tables for Supabase specific features ---

// Google OAuth Tokens Table
export const googleTokens = pgTable("google_tokens", {
  userId: uuid("user_id").primaryKey().references(() => profiles.id, { onDelete: 'cascade' }), // Foreign key to profiles table
  accessToken: text("access_token").notNull(),
  refreshToken: text("refresh_token"),
  expiryDate: timestamp("expiry_date").notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export type InsertGoogleToken = typeof googleTokens.$inferInsert;
export type GoogleToken = typeof googleTokens.$inferSelect;

// Audit Logs Table
export const auditLogs = pgTable("audit_logs", {
  id: serial("id").primaryKey(),
  timestamp: timestamp("timestamp").defaultNow().notNull(),
  userId: uuid("user_id").references(() => profiles.id, { onDelete: 'set null' }), // Can be null if action is system-generated or user deleted
  type: text("event_type").notNull(), // e.g., 'LEAD_CREATED', 'USER_LOGIN_FAILED'
  ipAddress: text("ip_address"), // Optional, may not always be available or accurate
  details: jsonb("details"), // Store any relevant JSON data about the event
});

export type InsertAuditLog = typeof auditLogs.$inferInsert;
export type AuditLog = typeof auditLogs.$inferSelect;


// --- Relations ---
// Define relations if you need to query them with Drizzle ORM
// Example: Leads related to Students
export const studentRelations = relations(students, ({ one }) => ({
  lead: one(leads, {
    fields: [students.leadId],
    references: [leads.id],
  }),
}));

export const taskRelations = relations(tasks, ({ one, many }) => ({
  assignedTo: one(profiles, {
    fields: [tasks.assignedToId],
    references: [profiles.id],
    relationName: 'taskAssignedTo',
  }),
  assignedBy: one(profiles, {
    fields: [tasks.assignedById],
    references: [profiles.id],
    relationName: 'taskAssignedBy',
  }),
  relatedLead: one(leads, {
    fields: [tasks.relatedLeadId],
    references: [leads.id],
  }),
  comments: many(taskComments),
}));

export const taskCommentRelations = relations(taskComments, ({ one }) => ({
  task: one(tasks, {
    fields: [taskComments.taskId],
    references: [tasks.id],
  }),
  user: one(profiles, { // Changed from users to profiles
    fields: [taskComments.userId],
    references: [profiles.id],
  }),
}));

export const sessionRelations = relations(sessions, ({ one, many }) => ({
  student: one(students, {
    fields: [sessions.studentId],
    references: [students.id],
  }),
  trainer: one(trainers, {
    fields: [sessions.trainerId],
    references: [trainers.id],
  }),
  history: many(sessionHistory),
}));

export const sessionHistoryRelations = relations(sessionHistory, ({ one }) => ({
  session: one(sessions, {
    fields: [sessionHistory.sessionId],
    references: [sessions.id],
  }),
  user: one(profiles, { // Changed from users to profiles
    fields: [sessionHistory.userId],
    references: [profiles.id],
  }),
}));

export const whatsappMessageRelations = relations(whatsappMessages, ({ one }) => ({
  lead: one(leads, {
    fields: [whatsappMessages.leadId],
    references: [leads.id],
  }),
}));

// Relation from profiles to auth.users (conceptual, as auth.users is managed by Supabase)
// export const profileAuthUserRelations = relations(profiles, ({ one }) => ({
//   authUser: one(authUsers, {
//     fields: [profiles.id],
//     references: [authUsers.id],
//   }),
// }));

// Note: The old 'users' table relations would need to be updated to 'profiles'
// if they were used extensively. For example, if tasks were related directly to the old 'users' table.
// The current changes assume tasks and comments will now relate to 'profiles.id' (which is auth.users.id).
