import { 
  leads, students, trainers, sessions, sessionHistory, whatsappMessages,
  tasks, taskWatchers, taskChecklistItems, taskComments, taskHistory,
  type Lead, type InsertLead, 
  type User, type InsertUser, 
  type Student, type InsertStudent,
  type Trainer, type InsertTrainer,
  type Session, type InsertSession,
  type SessionHistory, type InsertSessionHistory,
  type WhatsappMessage, type InsertWhatsappMessage,
  type Task, type InsertTask,
  type TaskWatcher, type InsertTaskWatcher,
  type TaskChecklistItem, type InsertTaskChecklistItem,
  type TaskComment, type InsertTaskComment,
  type TaskHistory, type InsertTaskHistory,
  users 
} from "@shared/schema";
import { db, pool } from "./db";
import { eq, and, desc, asc, between, inArray, or, like, sql } from "drizzle-orm";
import session from "express-session";
import connectPg from "connect-pg-simple";
import { alias } from "drizzle-orm/pg-core";

// modify the interface with any CRUD methods
// you might need

export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getAllUsers(): Promise<User[]>;
  createUser(user: InsertUser): Promise<User>;
  updateUser(id: number, user: Partial<InsertUser>): Promise<User | undefined>;
  deleteUser(id: number): Promise<boolean>;
  
  // Lead methods
  getLead(id: number): Promise<Lead | undefined>;
  getLeads(): Promise<Lead[]>;
  createLead(lead: InsertLead): Promise<Lead>;
  updateLead(id: number, lead: Partial<InsertLead>): Promise<Lead | undefined>;
  deleteLead(id: number): Promise<boolean>;
  searchLeads(query: string): Promise<Lead[]>;
  findLeadByEmail(email: string): Promise<Lead | undefined>;
  findLeadByPhone(phone: string): Promise<Lead | undefined>;
  getLeadsByStatus(status: string): Promise<Lead[]>;
  getLeadsByTag(tag: string): Promise<Lead[]>;
  getLeadsByDateRange(startDate: Date, endDate: Date): Promise<Lead[]>;
  getLeadsByStatuses(statuses: string[]): Promise<Lead[]>;
  getLeadsTags(): Promise<{tag: string, count: number}[]>;
  getLeadsTagsAggregated(): Promise<{tag: string, count: number}[]>;

  // Student methods
  getStudent(id: number): Promise<Student | undefined>;
  getStudents(): Promise<Student[]>;
  createStudent(student: InsertStudent): Promise<Student>;
  updateStudent(id: number, student: Partial<InsertStudent>): Promise<Student | undefined>;
  deleteStudent(id: number): Promise<boolean>;
  searchStudents(query: string): Promise<Student[]>;
  getStudentByLeadId(leadId: number): Promise<Student | undefined>;
  getStudentsWithLeads(): Promise<any[]>;
  getActiveStudents(): Promise<Student[]>;

  // Trainer methods
  getTrainer(id: number): Promise<Trainer | undefined>;
  getTrainers(): Promise<Trainer[]>;
  createTrainer(trainer: InsertTrainer): Promise<Trainer>;
  updateTrainer(id: number, trainer: Partial<InsertTrainer>): Promise<Trainer | undefined>;
  deleteTrainer(id: number): Promise<boolean>;
  getTrainerById(id: number): Promise<Trainer | undefined>;
  getTrainerByUserId(userId: number): Promise<Trainer | undefined>;
  getAvailableTrainers(): Promise<Trainer[]>;

  // Session methods
  getSession(id: number): Promise<Session | undefined>;
  getSessions(): Promise<Session[]>;
  createSession(sessionData: InsertSession): Promise<Session>;
  updateSession(id: number, sessionData: Partial<InsertSession>): Promise<Session | undefined>;
  deleteSession(id: number): Promise<boolean>;
  getSessionsForTrainer(trainerId: number, startDate: Date, endDate: Date): Promise<Session[]>;
  getSessionsForStudent(studentId: number): Promise<Session[]>;
  getUpcomingSessions(limit?: number): Promise<Session[]>;
  getSessionsInDateRange(startDate: Date, endDate: Date): Promise<Session[]>;
  getSessionWithDetails(id: number): Promise<any>;
  addSessionHistory(history: InsertSessionHistory): Promise<SessionHistory>;
  getSessionHistory(sessionId: number): Promise<SessionHistory[]>;

  // WhatsApp methods
  createWhatsAppMessage(message: InsertWhatsappMessage): Promise<WhatsappMessage>;
  getWhatsAppMessagesForLead(leadId: number): Promise<WhatsappMessage[]>;
  deleteWhatsAppMessage(id: number): Promise<boolean>;

  // Task methods
  getTasks(): Promise<Task[]>;
  getTasksByUserId(userId: number): Promise<Task[]>;
  getTasksByStatus(status: string): Promise<Task[]>;
  getTasksByPriority(priority: string): Promise<Task[]>;
  getTasksByTag(tag: string): Promise<Task[]>;
  getTaskByIdWithDetails(id: number): Promise<any>;
  getTask(id: number): Promise<Task | undefined>;
  createTask(taskData: InsertTask): Promise<Task>;
  updateTask(id: number, updates: Partial<InsertTask>): Promise<Task | undefined>;
  deleteTask(id: number): Promise<boolean>;
  getTaskWatchers(taskId: number): Promise<TaskWatcher[]>;
  addTaskWatcher(watcher: InsertTaskWatcher): Promise<TaskWatcher>;
  removeTaskWatcher(taskId: number, userId: number): Promise<boolean>;
  getTaskChecklistItems(taskId: number): Promise<TaskChecklistItem[]>;
  createTaskChecklistItem(item: InsertTaskChecklistItem): Promise<TaskChecklistItem>;
  updateTaskChecklistItem(id: number, updates: Partial<InsertTaskChecklistItem>): Promise<TaskChecklistItem | undefined>;
  deleteTaskChecklistItem(id: number): Promise<boolean>;
  getTaskComments(taskId: number, page?: number, limit?: number): Promise<TaskComment[]>;
  createTaskComment(comment: InsertTaskComment): Promise<TaskComment>;
  deleteTaskComment(id: number): Promise<boolean>;
  createTaskHistory(history: InsertTaskHistory): Promise<TaskHistory>;
  getTaskHistoryByTaskId(taskId: number): Promise<TaskHistory[]>;
}

class DatabaseStorage implements IStorage {
  // User methods
  async getUser(id: number): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.id, id));
    return result[0];
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const result = await db.select().from(users).where(eq(users.username, username));
    return result[0];
  }

  async getAllUsers(): Promise<User[]> {
    return await db.select().from(users);
  }

  async createUser(user: InsertUser): Promise<User> {
    const [newUser] = await db.insert(users).values(user).returning();
    return newUser;
  }

  async updateUser(id: number, user: Partial<InsertUser>): Promise<User | undefined> {
    const [updatedUser] = await db
      .update(users)
      .set(user)
      .where(eq(users.id, id))
      .returning();
    return updatedUser;
  }

  async deleteUser(id: number): Promise<boolean> {
    const result = await db.delete(users).where(eq(users.id, id));
    return result.rowCount > 0;
  }

  // Lead methods
  async getLead(id: number): Promise<Lead | undefined> {
    const result = await db.select().from(leads).where(eq(leads.id, id));
    return result[0];
  }

  async getLeads(): Promise<Lead[]> {
    return await db.select().from(leads);
  }

  async createLead(lead: InsertLead): Promise<Lead> {
    const [newLead] = await db.insert(leads).values({
      ...lead,
      entryDate: lead.entryDate instanceof Date ? lead.entryDate : new Date(lead.entryDate || Date.now()),
      createdAt: new Date(),
      updatedAt: new Date()
    }).returning();
    return newLead;
  }

  async updateLead(id: number, lead: Partial<InsertLead>): Promise<Lead | undefined> {
    // Normalize entryDate if it's a string
    if (lead.entryDate && typeof lead.entryDate === 'string') {
      lead.entryDate = new Date(lead.entryDate);
    }
    
    const [updatedLead] = await db
      .update(leads)
      .set({
        ...lead,
        updatedAt: new Date()
      })
      .where(eq(leads.id, id))
      .returning();
    return updatedLead;
  }

  async deleteLead(id: number): Promise<boolean> {
    const result = await db.delete(leads).where(eq(leads.id, id));
    return result.rowCount > 0;
  }

  async searchLeads(query: string): Promise<Lead[]> {
    // Normalize the search query
    const normalizedQuery = query.trim().toLowerCase();
    
    return await db
      .select()
      .from(leads)
      .where(
        or(
          like(leads.name.toLowerCase(), `%${normalizedQuery}%`),
          like(leads.email.toLowerCase(), `%${normalizedQuery}%`),
          like(leads.phone.toLowerCase(), `%${normalizedQuery}%`),
          sql`${leads.tags}::text ILIKE ${'%' + normalizedQuery + '%'}`
        )
      )
      .orderBy(desc(leads.updatedAt));
  }

  async findLeadByEmail(email: string): Promise<Lead | undefined> {
    const result = await db.select().from(leads).where(eq(leads.email, email));
    return result[0];
  }

  async findLeadByPhone(phone: string): Promise<Lead | undefined> {
    const result = await db.select().from(leads).where(eq(leads.phone, phone));
    return result[0];
  }

  async getLeadsByStatus(status: string): Promise<Lead[]> {
    return await db
      .select()
      .from(leads)
      .where(eq(leads.status, status))
      .orderBy(desc(leads.updatedAt));
  }

  async getLeadsByTag(tag: string): Promise<Lead[]> {
    return await db
      .select()
      .from(leads)
      .where(sql`${tag} = ANY(${leads.tags})`)
      .orderBy(desc(leads.updatedAt));
  }

  async getLeadsByDateRange(startDate: Date, endDate: Date): Promise<Lead[]> {
    return await db
      .select()
      .from(leads)
      .where(
        and(
          between(leads.entryDate, startDate, endDate)
        )
      )
      .orderBy(desc(leads.entryDate));
  }

  async getLeadsByStatuses(statuses: string[]): Promise<Lead[]> {
    return await db
      .select()
      .from(leads)
      .where(inArray(leads.status, statuses))
      .orderBy(desc(leads.updatedAt));
  }

  async getLeadsTags(): Promise<{tag: string, count: number}[]> {
    // Este método retorna todas as tags distintas presentes nos leads junto com a contagem de cada tag
    const result = await db.execute(sql`
      SELECT tag, COUNT(*) as count
      FROM leads, unnest(tags) as tag
      GROUP BY tag
      ORDER BY count DESC, tag ASC
    `);
    return result.rows as {tag: string, count: number}[];
  }

  async getLeadsTagsAggregated(): Promise<{ tag: string, count: number }[]> {
    // Simplificado para retornar mesmos dados do método anterior
    // Em implementação real, poderia fazer cálculos mais complexos ou personalizados
    return this.getLeadsTags();
  }

  // Student methods
  async getStudent(id: number): Promise<Student | undefined> {
    const result = await db.select().from(students).where(eq(students.id, id));
    return result[0];
  }

  async getStudents(): Promise<Student[]> {
    return await db.select().from(students);
  }

  async createStudent(student: InsertStudent): Promise<Student> {
    const [newStudent] = await db.insert(students).values({
      ...student,
      createdAt: new Date(),
      updatedAt: new Date()
    }).returning();
    return newStudent;
  }

  async updateStudent(id: number, student: Partial<InsertStudent>): Promise<Student | undefined> {
    const [updatedStudent] = await db
      .update(students)
      .set({
        ...student,
        updatedAt: new Date()
      })
      .where(eq(students.id, id))
      .returning();
    return updatedStudent;
  }

  async deleteStudent(id: number): Promise<boolean> {
    const result = await db.delete(students).where(eq(students.id, id));
    return result.rowCount > 0;
  }

  async searchStudents(query: string): Promise<Student[]> {
    // Join com a tabela de leads para buscar por nome ou email do lead
    const lead = alias(leads, "lead");
    
    return await db
      .select()
      .from(students)
      .leftJoin(lead, eq(students.leadId, lead.id))
      .where(
        or(
          // Buscar no nome ou email do lead
          like(lead.name.toLowerCase(), `%${query.toLowerCase()}%`),
          like(lead.email.toLowerCase(), `%${query.toLowerCase()}%`),
          // Buscar nos campos do próprio estudante
          like(students.address.toLowerCase(), `%${query.toLowerCase()}%`)
        )
      );
  }

  async getStudentByLeadId(leadId: number): Promise<Student | undefined> {
    const result = await db.select().from(students).where(eq(students.leadId, leadId));
    return result[0];
  }

  async getStudentsWithLeads(): Promise<any[]> {
    const result = await db
      .select({
        student: students,
        lead: leads
      })
      .from(students)
      .leftJoin(leads, eq(students.leadId, leads.id));
    
    return result;
  }

  async getActiveStudents(): Promise<Student[]> {
    return await db
      .select()
      .from(students)
      .where(eq(students.active, true))
      .orderBy(desc(students.updatedAt));
  }

  // Trainer methods
  async getTrainer(id: number): Promise<Trainer | undefined> {
    const result = await db.select().from(trainers).where(eq(trainers.id, id));
    return result[0];
  }

  async getTrainers(): Promise<Trainer[]> {
    return await db.select().from(trainers);
  }

  async createTrainer(trainer: InsertTrainer): Promise<Trainer> {
    const [newTrainer] = await db.insert(trainers).values({
      ...trainer,
      createdAt: new Date(),
      updatedAt: new Date()
    }).returning();
    return newTrainer;
  }

  async updateTrainer(id: number, trainer: Partial<InsertTrainer>): Promise<Trainer | undefined> {
    const [updatedTrainer] = await db
      .update(trainers)
      .set({
        ...trainer,
        updatedAt: new Date()
      })
      .where(eq(trainers.id, id))
      .returning();
    return updatedTrainer;
  }

  async deleteTrainer(id: number): Promise<boolean> {
    const result = await db.delete(trainers).where(eq(trainers.id, id));
    return result.rowCount > 0;
  }

  async getTrainerById(id: number): Promise<Trainer | undefined> {
    return this.getTrainer(id);
  }

  async getTrainerByUserId(userId: number): Promise<Trainer | undefined> {
    const result = await db.select().from(trainers).where(eq(trainers.userId, userId));
    return result[0];
  }

  async getAvailableTrainers(): Promise<Trainer[]> {
    return await db
      .select()
      .from(trainers)
      .where(eq(trainers.available, true))
      .orderBy(asc(trainers.name));
  }

  // Session methods
  async getSession(id: number): Promise<Session | undefined> {
    const result = await db.select().from(sessions).where(eq(sessions.id, id));
    return result[0];
  }

  async getSessions(): Promise<Session[]> {
    return await db.select().from(sessions);
  }

  async createSession(sessionData: InsertSession): Promise<Session> {
    const [newSession] = await db.insert(sessions).values({
      ...sessionData,
      confirmed: sessionData.confirmed || false,
      cancelled: sessionData.cancelled || false,
      completed: sessionData.completed || false,
      createdAt: new Date(),
      updatedAt: new Date()
    }).returning();
    return newSession;
  }

  async updateSession(id: number, sessionData: Partial<InsertSession>): Promise<Session | undefined> {
    const [updatedSession] = await db
      .update(sessions)
      .set({
        ...sessionData,
        updatedAt: new Date()
      })
      .where(eq(sessions.id, id))
      .returning();
    return updatedSession;
  }

  async deleteSession(id: number): Promise<boolean> {
    const result = await db.delete(sessions).where(eq(sessions.id, id));
    return result.rowCount > 0;
  }

  async getSessionsForTrainer(trainerId: number, startDate: Date, endDate: Date): Promise<Session[]> {
    return await db
      .select()
      .from(sessions)
      .where(
        and(
          eq(sessions.trainerId, trainerId),
          between(sessions.date, startDate, endDate)
        )
      )
      .orderBy(asc(sessions.date), asc(sessions.startTime));
  }

  async getSessionsForStudent(studentId: number): Promise<Session[]> {
    return await db
      .select()
      .from(sessions)
      .where(eq(sessions.studentId, studentId))
      .orderBy(desc(sessions.date), asc(sessions.startTime));
  }

  async getUpcomingSessions(limit: number = 10): Promise<Session[]> {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    return await db
      .select()
      .from(sessions)
      .where(
        and(
          // Data da sessão maior ou igual a hoje
          between(
            sessions.date,
            today,
            new Date(today.getTime() + 90 * 24 * 60 * 60 * 1000) // 90 dias a partir de hoje
          ),
          eq(sessions.cancelled, false)
        )
      )
      .orderBy(asc(sessions.date), asc(sessions.startTime))
      .limit(limit);
  }

  async getSessionsInDateRange(startDate: Date, endDate: Date): Promise<Session[]> {
    return await db
      .select()
      .from(sessions)
      .where(between(sessions.date, startDate, endDate))
      .orderBy(asc(sessions.date), asc(sessions.startTime));
  }

  async getSessionWithDetails(id: number): Promise<any> {
    // Obter a sessão
    const [session] = await db
      .select()
      .from(sessions)
      .where(eq(sessions.id, id));
    
    if (!session) return null;
    
    // Obter o treinador
    const trainer = await this.getTrainer(session.trainerId);
    
    // Obter o aluno
    const student = await this.getStudent(session.studentId);
    
    // Obter o histórico da sessão
    const history = await this.getSessionHistory(id);
    
    return {
      ...session,
      trainer,
      student,
      history
    };
  }

  async addSessionHistory(history: InsertSessionHistory): Promise<SessionHistory> {
    const [record] = await db
      .insert(sessionHistory)
      .values({
        ...history,
        createdAt: new Date()
      })
      .returning();
    return record;
  }

  async getSessionHistory(sessionId: number): Promise<SessionHistory[]> {
    return await db
      .select()
      .from(sessionHistory)
      .where(eq(sessionHistory.sessionId, sessionId))
      .orderBy(desc(sessionHistory.createdAt));
  }

  // WhatsApp methods
  async createWhatsAppMessage(message: InsertWhatsappMessage): Promise<WhatsappMessage> {
    try {
      const [result] = await db
        .insert(whatsappMessages)
        .values({
          ...message,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();
      
      return result;
    } catch (error) {
      console.error("Erro ao criar mensagem WhatsApp:", error);
      throw error;
    }
  }

  async getWhatsAppMessagesForLead(leadId: number): Promise<WhatsappMessage[]> {
    try {
      return await db
        .select()
        .from(whatsappMessages)
        .where(eq(whatsappMessages.leadId, leadId))
        .orderBy(desc(whatsappMessages.createdAt));
    } catch (error) {
      console.error("Erro ao buscar mensagens WhatsApp:", error);
      return [];
    }
  }

  async deleteWhatsAppMessage(id: number): Promise<boolean> {
    try {
      await db
        .delete(whatsappMessages)
        .where(eq(whatsappMessages.id, id));
      
      return true;
    } catch (error) {
      console.error("Erro ao excluir mensagem:", error);
      return false;
    }
  }

  // Task methods - métodos relacionados a tarefas foram movidos para task-storage.ts
  async getTasks(): Promise<Task[]> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async getTasksByUserId(userId: number): Promise<Task[]> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async getTasksByStatus(status: string): Promise<Task[]> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async getTasksByPriority(priority: string): Promise<Task[]> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async getTasksByTag(tag: string): Promise<Task[]> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async getTaskByIdWithDetails(id: number): Promise<any> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async getTask(id: number): Promise<Task | undefined> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async createTask(taskData: InsertTask): Promise<Task> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async updateTask(id: number, updates: Partial<InsertTask>): Promise<Task | undefined> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async deleteTask(id: number): Promise<boolean> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async getTaskWatchers(taskId: number): Promise<TaskWatcher[]> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async addTaskWatcher(watcher: InsertTaskWatcher): Promise<TaskWatcher> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async removeTaskWatcher(taskId: number, userId: number): Promise<boolean> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async getTaskChecklistItems(taskId: number): Promise<TaskChecklistItem[]> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async createTaskChecklistItem(item: InsertTaskChecklistItem): Promise<TaskChecklistItem> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async updateTaskChecklistItem(id: number, updates: Partial<InsertTaskChecklistItem>): Promise<TaskChecklistItem | undefined> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async deleteTaskChecklistItem(id: number): Promise<boolean> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async getTaskComments(taskId: number, page: number = 1, limit: number = 20): Promise<TaskComment[]> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async createTaskComment(comment: InsertTaskComment): Promise<TaskComment> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async deleteTaskComment(id: number): Promise<boolean> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async createTaskHistory(history: InsertTaskHistory): Promise<TaskHistory> {
    throw new Error("Método transferido para task-storage.ts");
  }

  async getTaskHistoryByTaskId(taskId: number): Promise<TaskHistory[]> {
    throw new Error("Método transferido para task-storage.ts");
  }
}

export const storage = new DatabaseStorage();