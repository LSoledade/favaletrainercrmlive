// Follow this setup guide to integrate the Deno language server with your editor:
// https://deno.land/manual/getting_started/setup_your_environment
// This enables autocomplete, go to definition, etc.

import "jsr:@supabase/functions-js/edge-runtime.d.ts"
import { createClient, SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { z } from "https://deno.land/x/zod@v3.23.4/mod.ts";
import { fromZodError, ZodError } from "https://deno.land/x/zod_validation_error@v3.0.3/mod.ts";

// --- Env Vars & Supabase Clients ---
const supabaseUrl = Deno.env.get('SUPABASE_URL');
const serviceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
const anonKey = Deno.env.get('SUPABASE_ANON_KEY');

const evolutionApiUrlEnv = Deno.env.get('EVOLUTION_API_URL'); // Recommended to store in Vault
const evolutionApiTokenEnv = Deno.env.get('EVOLUTION_API_TOKEN'); // Recommended to store in Vault
const evolutionApiInstanceEnv = Deno.env.get('EVOLUTION_API_INSTANCE') || 'default';
const whatsappWebhookVerifyTokenEnv = Deno.env.get('WHATSAPP_WEBHOOK_VERIFY_TOKEN') || 'YOUR_VERY_SECURE_VERIFY_TOKEN';

if (!supabaseUrl || !serviceRoleKey || !anonKey) {
    console.error("Supabase URL, Service Role Key, or Anon Key is missing.");
}
// evolutionApiUrlEnv and evolutionApiTokenEnv will be fetched from DB or fallback to ENV

// --- Zod Schemas for Validation (column names should match DB) ---
const whatsappConfigSchema = z.object({
    api_url: z.string().url("URL da API inválida."),
    api_token: z.string().min(1, "Token da API é obrigatório."),
    api_instance: z.string().min(1, "Instância da API é obrigatória.").default("default"),
});
type WhatsappConfig = z.infer<typeof whatsappConfigSchema>;

const sendMessageSchema = z.object({
    lead_id: z.number().int().positive(),
    content: z.string().min(1, "Conteúdo da mensagem é obrigatório."),
    // media_url: z.string().url().optional(), // For sending media messages
    // media_type: z.enum(["image", "video", "audio", "document"]).optional(),
});

const sendTemplateMessageSchema = z.object({
    lead_id: z.number().int().positive({ message: "ID do Lead inválido."}),
    template_name: z.string().min(1, "Nome do template é obrigatório."),
    language_code: z.string().min(2, "Código de idioma inválido.").default("pt_BR"),
    // Parameters for the template body (e.g., replacing {{1}}, {{2}})
    body_params: z.array(z.string()).optional().default([]),
    // Parameters for header variables (if any)
    header_params: z.array(z.string()).optional().default([]),
    // For templates with media in header
    header_media_url: z.string().url("URL da mídia do cabeçalho inválida.").optional(),
    header_media_type: z.enum(["IMAGE", "VIDEO", "DOCUMENT"]).optional(),
    // For templates with buttons (this structure can vary significantly)
    // Example: quick reply buttons
    buttons_params: z.array(z.object({
        type: z.literal("QUICK_REPLY"), // or "URL", "PHONE_NUMBER"
        payload: z.string(), // or URL / phone number
        text: z.string(),
    })).optional(),
});


// --- Types (ensure column names like lead_id, message_id match DB) ---
interface Lead { id: number; name: string; phone: string; } // Simplified
interface WhatsappMessage {
  id?: number;
  lead_id: number; // Foreign Key to leads table
  direction: 'incoming' | 'outgoing';
  content: string;
  status: 'pending' | 'sent' | 'delivered' | 'read' | 'failed' | 'received'; // Consistent statuses
  media_url?: string | null;
  media_type?: string | null;
  message_id?: string | null; // API provider's message ID (e.g., from Evolution)
  timestamp?: string | Date; // Auto-generated by DB ideally
  error_message?: string | null; // To store error details if sending failed
}
interface EvolutionApiResponse { // Generic structure for Evolution API responses
  success: boolean;
  key?: { id: string }; // For message sending response
  id?: string; // Sometimes ID is directly on response
  error?: string; // Error message from Evolution
  message?: string; // Alternative error message field
  data?: any; // For status, qrcode etc.
  instance?: any; // For instance status
  groups?: any[]; // For group list
  contacts?: any[]; // For contact list
  status?: string; // For message status check
  // Add other fields based on specific Evolution API responses
}


// --- Database Interaction Helpers (using admin client for security) ---
async function getSupabaseAdminClient(): Promise<SupabaseClient> {
    if (!supabaseUrl || !serviceRoleKey) throw new Error("Supabase admin client config missing.");
    return createClient(supabaseUrl, serviceRoleKey);
}

async function findLeadById(adminClient: SupabaseClient, leadId: number): Promise<Lead | null> {
  const { data, error } = await adminClient.from('leads').select('id, name, phone').eq('id', leadId).single();
  if (error && error.code !== 'PGRST116') console.error("Error finding lead by ID:", error.message);
  return data as Lead | null;
}
async function findLeadByPhone(adminClient: SupabaseClient, phoneNumber: string): Promise<Lead | null> {
    const normalized = normalizePhoneForComparison(phoneNumber);
    // Query for exact match or international format without '+'
    const { data, error } = await adminClient.from('leads')
        .select('id, name, phone')
        .or(`phone.eq.${normalized},phone.like.%${normalized.slice(-9)}`) // Match full or last 9 digits
        .limit(1).single();
    if (error && error.code !== 'PGRST116') console.error("Error finding lead by phone:", error.message);
    return data as Lead | null;
}

async function getWhatsappMessagesForLead(adminClient: SupabaseClient, leadId: number, limit: number = 50): Promise<WhatsappMessage[]> {
  const { data, error } = await adminClient.from('whatsapp_messages')
    .select('*').eq('lead_id', leadId)
    .order('timestamp', { ascending: false }).limit(limit);
  if (error) console.error("Error getting messages for lead:", error.message);
  return (data as WhatsappMessage[] | null) || [];
}
async function getWhatsappMessageByApiId(adminClient: SupabaseClient, apiMessageId: string): Promise<WhatsappMessage | null> {
    const { data, error } = await adminClient.from('whatsapp_messages').select('*').eq('message_id', apiMessageId).single();
    if (error && error.code !== 'PGRST116') console.error("Error getting message by API ID:", error.message);
    return data as WhatsappMessage | null;
}
async function createWhatsappMessageInDb(adminClient: SupabaseClient, message: Omit<WhatsappMessage, 'id' | 'timestamp'>): Promise<WhatsappMessage> {
  const { data, error } = await adminClient.from('whatsapp_messages').insert(message).select().single();
  if (error) throw new Error(`DB error creating message: ${error.message}`);
  return data as WhatsappMessage;
}
async function updateWhatsappMessageStatusInDb(adminClient: SupabaseClient, id: number, status: WhatsappMessage['status'], errorMessage?: string | null): Promise<WhatsappMessage | null> {
  const { data, error } = await adminClient.from('whatsapp_messages').update({ status, error_message: errorMessage }).eq('id', id).select().single();
  if (error) console.error("Error updating message status:", error.message);
  return data as WhatsappMessage | null;
}
async function updateWhatsappMessageApiIdInDb(adminClient: SupabaseClient, id: number, apiMessageId: string): Promise<WhatsappMessage | null> {
    const { data, error } = await adminClient.from('whatsapp_messages').update({ message_id: apiMessageId }).eq('id', id).select().single();
    if (error) console.error("Error updating message API ID:", error.message);
    return data as WhatsappMessage | null;
}

async function getWhatsappConfigFromDb(adminClient: SupabaseClient): Promise<WhatsappConfig> {
    const { data, error } = await adminClient.from('whatsapp_settings').select('api_url, api_token, api_instance').order('updated_at', { ascending: false }).limit(1).single();
    if (error && error.code !== 'PGRST116') { // PGRST116: no rows found
        console.warn("Error fetching whatsapp config from DB, using ENV fallbacks:", error.message);
    }
    if (data) return data as WhatsappConfig;
    // Fallback to ENV variables if DB config is not found or error occurs
    if (evolutionApiUrlEnv && evolutionApiTokenEnv) {
        return { api_url: evolutionApiUrlEnv, api_token: evolutionApiTokenEnv, api_instance: evolutionApiInstanceEnv };
    }
    throw new Error("Configuração da API WhatsApp não encontrada no banco de dados nem nas variáveis de ambiente.");
}
async function saveWhatsappConfigToDb(adminClient: SupabaseClient, config: WhatsappConfig): Promise<WhatsappConfig> {
    // Upsert logic: delete old configs, insert new one. Or use DB's ON CONFLICT.
    // For simplicity, assuming a single row or always inserting and relying on the SELECT query to get the latest.
    // A more robust way is to have an 'id' and upsert on it or a 'profile_id' if settings are per-user/profile.
    // Here, we'll just insert. Frontend should fetch before saving to avoid multiple rows if not intended.
    const { data, error } = await adminClient.from('whatsapp_settings').insert(config).select().single();
    if (error) throw new Error(`DB error saving whatsapp config: ${error.message}`);
    return data as WhatsappConfig;
}

// --- Evolution API Interaction ---
function normalizePhoneForComparison(phone: string | undefined | null): string {
  if (!phone) return '';
  return phone.replace(/\D/g, ''); // Remove all non-digits
}
function formatPhoneNumberForApi(phone: string | undefined | null): string | null {
    if (!phone) return null;
    let cleaned = normalizePhoneForComparison(phone);
    // Basic Brazilian phone number formatting assumption for Evolution API
    if (!cleaned.startsWith('55') && (cleaned.length === 10 || cleaned.length === 11)) {
        cleaned = '55' + cleaned;
    }
    // Add more specific country code logic if needed
    return cleaned.length < 10 ? null : cleaned; // Minimal validation
}

interface EvolutionRequestResult {
  success: boolean;
  data?: EvolutionApiResponse; // Parsed JSON data from Evolution
  error?: string; // Error message for internal/network errors
  statusCode?: number; // HTTP status code from Evolution
}

async function makeEvolutionRequest(config: WhatsappConfig, endpoint: string, method = 'GET', body: any = null): Promise<EvolutionRequestResult> {
  const { api_url, api_token, api_instance } = config;
  if (!api_url || !api_token) return { success: false, error: "Configuração da Evolution API (URL ou Token) está incompleta." };

  const finalEndpoint = endpoint.replace('{instance}', api_instance);
  const fullUrl = `${api_url.replace(/\/$/, '')}${finalEndpoint}`; // Ensure no double slashes

  try {
    const response = await fetch(fullUrl, {
      method,
      headers: { 'Content-Type': 'application/json', 'apikey': api_token },
      body: body ? JSON.stringify(body) : undefined,
    });
    const responseData: EvolutionApiResponse = await response.json();

    if (!response.ok || responseData.error || responseData.message) { // Check common error fields from Evolution
      return { success: false, error: responseData.error || responseData.message || `Erro da API Evolution: ${response.status}`, data: responseData, statusCode: response.status };
    }
    return { success: true, data: responseData, statusCode: response.status };
  } catch (e) {
    console.error(`Error making Evolution request to ${fullUrl}:`, e.message);
    return { success: false, error: e.message };
  }
}

// --- Main Handler ---
Deno.serve(async (req: Request) => {
  const headers = { "Content-Type": "application/json" };
  if (!supabaseUrl || !serviceRoleKey || !anonKey) {
    return new Response(JSON.stringify({ error: "Configuração crítica do servidor ausente." }), { status: 503, headers });
  }

  const adminClient = await getSupabaseAdminClient();
  const userAuthClient = createClient(supabaseUrl, anonKey, { global: { headers: { Authorization: req.headers.get('Authorization')! }}});

  const url = new URL(req.url);
  const pathParts = url.pathname.split('/').filter(p => p);
  const mainAction = pathParts[3]; // e.g. 'config', 'send', 'status', 'webhook'
  const param1 = pathParts[4]; // e.g. lead_id for messages, message_id for status
  const param2 = pathParts[5]; // e.g. 'status' for updating message status

  // --- Webhook Handling (NO AUTH for Meta verification, message intake needs validation if not from trusted source) ---
  if (mainAction === 'webhook') {
    if (req.method === 'POST') {
      try {
        const payload = await req.json();
        console.log('Webhook POST recebido:', JSON.stringify(payload, null, 2));
        // Example: Meta/Facebook Webhook for incoming messages
        if (payload?.object === 'whatsapp_business_account' && payload?.entry?.[0]?.changes?.[0]?.value?.messages?.[0]) {
            const message = payload.entry[0].changes[0].value.messages[0];
            if (message.from && message.id && message.type === 'text') { // Handle only text messages for now
                const lead = await findLeadByPhone(adminClient, message.from);
                if (lead) {
                    await createWhatsappMessageInDb(adminClient, {
                        lead_id: lead.id,
                        direction: 'incoming',
                        content: message.text.body,
                        status: 'received', // Or 'read' if auto-read logic is implemented
                        message_id: message.id, // Store Meta's message ID
                        media_type: 'text'
                    });
                } else {
                    console.warn(`Webhook: Lead não encontrado para o número ${message.from}`);
                }
            }
            // TODO: Add handling for other incoming message types (media, location, etc.)
        } else if (payload?.entry?.[0]?.changes?.[0]?.value?.statuses?.[0]) {
            // Handle message status updates from Meta
            const statusUpdate = payload.entry[0].changes[0].value.statuses[0];
            const wamid = statusUpdate.id; // WhatsApp Message ID
            const newStatus = statusUpdate.status as WhatsappMessage['status']; // sent, delivered, read, failed
            const timestamp = statusUpdate.timestamp; // Unix timestamp
            const recipientPhone = statusUpdate.recipient_id; // User's phone

            console.log(`Webhook: Status update received for WAMID ${wamid}: ${newStatus} for ${recipientPhone} at ${new Date(parseInt(timestamp) * 1000).toISOString()}`);

            if (wamid && newStatus && ['sent', 'delivered', 'read', 'failed'].includes(newStatus)) {
                const dbMessage = await getWhatsappMessageByApiId(adminClient, wamid);
                if (dbMessage) {
                    // Prevent overwriting a "read" status with "delivered", for example.
                    const statusOrder = { pending: 0, sent: 1, delivered: 2, read: 3, failed: 4, received: 5 };
                    const currentStatusOrder = statusOrder[dbMessage.status] ?? -1;
                    const newStatusOrder = statusOrder[newStatus] ?? -1;

                    if (newStatusOrder > currentStatusOrder || newStatus === 'failed') { // Always update if failed or new status is "later"
                        await updateWhatsappMessageStatusInDb(adminClient, dbMessage.id!, newStatus, statusUpdate.errors?.[0]?.message);
                        console.log(`Webhook: Updated DB message ID ${dbMessage.id} (WAMID ${wamid}) to status ${newStatus}`);
                    } else {
                        console.log(`Webhook: Skipped updating status for WAMID ${wamid}. Current: ${dbMessage.status}, New: ${newStatus}`);
                    }
                } else {
                    console.warn(`Webhook: Message with WAMID ${wamid} not found in DB for status update.`);
                }
            }
        }
        // TODO: Add specific Evolution API webhook event processing here if applicable.
        return new Response('EVENT_RECEIVED', { status: 200 });
      } catch (e) {
        console.error("Erro ao processar webhook POST:", e.message, e.stack);
        return new Response(JSON.stringify({ error: "Erro ao processar webhook." }), { status: 400, headers });
      }
    }
    if (req.method === 'GET') { // For Meta/Facebook Webhook verification
      const mode = url.searchParams.get('hub.mode');
      const token = url.searchParams.get('hub.verify_token');
      const challenge = url.searchParams.get('hub.challenge');
      if (mode === 'subscribe' && token === whatsappWebhookVerifyTokenEnv) {
        console.log("Webhook GET verificado com sucesso.");
        return new Response(challenge, { status: 200 });
      }
      console.warn("Falha na verificação do Webhook GET.");
      return new Response('Forbidden', { status: 403 });
    }
    return new Response(JSON.stringify({ error: "Método não permitido para webhook." }), { status: 405, headers });
  }

  // --- Authenticated Routes Below ---
  const { data: { user: callingUser }, error: authError } = await userAuthClient.auth.getUser();
  if (authError || !callingUser) {
    return new Response(JSON.stringify({ error: "Não autenticado." }), { status: 401, headers });
  }
  // Fetch user role for permission checks
  const { data: profileData } = await adminClient.from('profiles').select('role').eq('id', callingUser.id).single();
  const callingUserRole = profileData?.role || 'user';


  try {
    const evolutionConfig = await getWhatsappConfigFromDb(adminClient); // Fetch current config

    // --- Configuration Management (Admin Only) ---
    if (mainAction === 'config') {
      if (callingUserRole !== 'admin') {
        return new Response(JSON.stringify({ error: "Acesso negado. Somente administradores." }), { status: 403, headers });
      }
      if (req.method === 'GET') {
        return new Response(JSON.stringify({ data: evolutionConfig }), { headers, status: 200 });
      }
      if (req.method === 'POST') {
        const body = await req.json();
        const validationResult = whatsappConfigSchema.safeParse(body);
        if (!validationResult.success) {
          return new Response(JSON.stringify({ error: "Dados de configuração inválidos.", details: fromZodError(validationResult.error).toString() }), { status: 400, headers });
        }
        const newConfig = await saveWhatsappConfigToDb(adminClient, validationResult.data);
        return new Response(JSON.stringify({ data: newConfig }), { headers, status: 200 });
      }
    }

    // --- Evolution API Instance Status & QR Code ---
    if (mainAction === 'status' && req.method === 'GET') {
        const result = await makeEvolutionRequest(evolutionConfig, `/instance/connectionState/{instance}`);
        return new Response(JSON.stringify(result), { headers, status: result.statusCode || (result.success ? 200 : 503) });
    }
    if (mainAction === 'qrcode' && req.method === 'GET') { // Or connect for QR
        const result = await makeEvolutionRequest(evolutionConfig, `/instance/connect/{instance}`); // This endpoint often provides QR if not connected
        return new Response(JSON.stringify(result.data || {error: result.error}), { headers, status: result.statusCode || (result.success ? 200 : 400 ) });
    }

    // --- Send Messages ---
    if (mainAction === 'send' && req.method === 'POST') {
        const body = await req.json();
        const validation = sendMessageSchema.safeParse(body);
        if (!validation.success) {
            return new Response(JSON.stringify({ error: "Dados de envio de mensagem inválidos.", details: fromZodError(validation.error).toString() }), { status: 400, headers });
        }
        const { lead_id, content } = validation.data;
        const lead = await findLeadById(adminClient, lead_id);
        if (!lead) return new Response(JSON.stringify({ error: "Lead não encontrado." }), { status: 404, headers });

        const phone = formatPhoneNumberForApi(lead.phone);
        if (!phone) return new Response(JSON.stringify({ error: "Número de telefone do lead inválido ou não formatado." }), { status: 400, headers });

        const dbMsg = await createWhatsappMessageInDb(adminClient, { lead_id, direction: 'outgoing', content, status: 'pending', media_type: 'text' });
        const evoPayload = { number: phone, options: { delay: 1200, presence: "composing" }, textMessage: { text: content } };
        const result = await makeEvolutionRequest(evolutionConfig, `/message/sendText/{instance}`, 'POST', evoPayload);

        if (result.success && result.data?.key?.id) {
            await updateWhatsappMessageApiIdInDb(adminClient, dbMsg.id!, result.data.key.id);
            await updateWhatsappMessageStatusInDb(adminClient, dbMsg.id!, 'sent');
        } else {
            await updateWhatsappMessageStatusInDb(adminClient, dbMsg.id!, 'failed', result.error || JSON.stringify(result.data));
        }
        return new Response(JSON.stringify({data: result.data, dbMessageId: dbMsg.id, status: result.success ? 'Enviado' : 'Falhou'}), { headers, status: result.success ? 201 : 400 });
    }

    // --- Send Template Message ---
    if (mainAction === 'send-template' && req.method === 'POST') {
        const body = await req.json();
        const validation = sendTemplateMessageSchema.safeParse(body);
        if (!validation.success) {
            return new Response(JSON.stringify({ error: "Dados de envio de template inválidos.", details: fromZodError(validation.error).toString() }), { status: 400, headers });
        }
        const { lead_id, template_name, language_code, body_params, header_params, header_media_url, header_media_type, buttons_params } = validation.data;

        const lead = await findLeadById(adminClient, lead_id);
        if (!lead) return new Response(JSON.stringify({ error: "Lead não encontrado." }), { status: 404, headers });
        const phone = formatPhoneNumberForApi(lead.phone);
        if (!phone) return new Response(JSON.stringify({ error: "Número de telefone do lead inválido." }), { status: 400, headers });

        // Construct the payload for Evolution API's sendTemplate endpoint
        // This payload structure is an assumption and might need adjustment based on actual Evolution API docs
        const evolutionPayload: any = {
            number: phone,
            name: template_name, // Evolution API might use 'name' for templateName
            language: { code: language_code, policy: "deterministic" },
            components: []
        };

        // Header Component (if any)
        if (header_media_url && header_media_type) {
            evolutionPayload.components.push({
                type: "header",
                parameters: [{ type: header_media_type.toLowerCase(), [header_media_type.toLowerCase()]: { link: header_media_url } }]
            });
        } else if (header_text_content) { // Assuming header_text_content for text headers
             evolutionPayload.components.push({
                type: "header",
                parameters: [{ type: "text", text: header_text_content }]
            });
        } else if (header_params && header_params.length > 0) { // Simpler text header vars
            evolutionPayload.components.push({
                type: "header",
                parameters: header_params.map(p => ({ type: "text", text: p }))
            });
        }


        // Body Component (if params exist)
        if (body_params && body_params.length > 0) {
            evolutionPayload.components.push({
                type: "body",
                parameters: body_params.map(param => ({ type: "text", text: param }))
            });
        }

        // Buttons Component (if any - example for quick replies)
        if (buttons_params && buttons_params.length > 0) {
            evolutionPayload.components.push({
                type: "button",
                sub_type: "quick_reply", // This can vary: "url", "call"
                index: "0", // index of the button if multiple quick reply buttons are defined in the template
                parameters: buttons_params.map(btn => ({ type: "payload", payload: btn.payload })) // or type: "text" for URL buttons
            });
        }

        // Log the message in DB (content can be the template name + params for reference)
        const dbContent = `Template: ${template_name} | Params: ${JSON.stringify(body_params)}`;
        const dbMsg = await createWhatsappMessageInDb(adminClient, { lead_id, direction: 'outgoing', content: dbContent, status: 'pending', media_type: 'template' });

        // Make the request to Evolution API
        // The endpoint /message/sendTemplate is a common convention, adjust if different for your Evolution API version
        const result = await makeEvolutionRequest(evolutionConfig, `/message/sendTemplate/{instance}`, 'POST', evolutionPayload);

        if (result.success && result.data?.key?.id) {
            await updateWhatsappMessageApiIdInDb(adminClient, dbMsg.id!, result.data.key.id);
            await updateWhatsappMessageStatusInDb(adminClient, dbMsg.id!, 'sent');
        } else {
            await updateWhatsappMessageStatusInDb(adminClient, dbMsg.id!, 'failed', result.error || JSON.stringify(result.data));
        }
        return new Response(JSON.stringify({ data: result.data, dbMessageId: dbMsg.id, status: result.success ? 'Template Enviado' : 'Falha no Envio do Template' }), { headers, status: result.success ? 201 : 400 });
    }
    // TODO: Add endpoints for other media messages (image, video, document, audio)

    // --- Message Management (Fetch, Update Status, Delete) ---
    if (mainAction === 'lead' && param1 && req.method === 'GET') { // Get messages for a specific lead
        const leadIdNum = parseInt(param1);
        if (isNaN(leadIdNum)) return new Response(JSON.stringify({ error: "ID do lead inválido." }), { status: 400, headers });
        const messages = await getWhatsappMessagesForLead(adminClient, leadIdNum);
        return new Response(JSON.stringify({ data: messages }), { headers, status: 200 });
    }
    // Example: Update message status by its DB ID (e.g., if callback from Evolution updates it)
    // This would typically be an internal or webhook-driven endpoint.
    if (mainAction === 'messages' && param1 && param2 === 'status' && req.method === 'PATCH') {
        const messageIdNum = parseInt(param1);
        if (isNaN(messageIdNum)) return new Response(JSON.stringify({ error: "ID da mensagem inválido." }), { status: 400, headers });
        const { status: newStatus, error_message } = await req.json(); // Expects { "status": "delivered", "error_message": null }
        if (!newStatus || !['pending', 'sent', 'delivered', 'read', 'failed', 'received'].includes(newStatus)) {
            return new Response(JSON.stringify({ error: "Status inválido fornecido." }), { status: 400, headers });
        }
        const updatedMsg = await updateWhatsappMessageStatusInDb(adminClient, messageIdNum, newStatus, error_message);
        if (!updatedMsg) return new Response(JSON.stringify({ error: "Mensagem não encontrada ou falha ao atualizar." }), { status: 404, headers });
        return new Response(JSON.stringify({ data: updatedMsg }), { headers, status: 200 });
    }
    // Example: Check Evolution API message status by Evolution's message ID
    if (mainAction === 'message-status' && param1 && req.method === 'GET') {
        const apiMessageId = param1; // This is Evolution's message ID
        const result = await makeEvolutionRequest(evolutionConfig, `/message/status/{instance}?id=${apiMessageId}`);
        if (result.success && result.data?.status) {
            const dbMessage = await getWhatsappMessageByApiId(adminClient, apiMessageId);
            if (dbMessage) { // Update our DB status based on Evolution's response
                const newStatus = result.data.status.toLowerCase() as WhatsappMessage['status']; // Ensure status matches enum
                if (['sent', 'delivered', 'read', 'failed'].includes(newStatus)) {
                     await updateWhatsappMessageStatusInDb(adminClient, dbMessage.id!, newStatus);
                }
            }
        }
        return new Response(JSON.stringify(result.data || {error: result.error}), { headers, status: result.statusCode || (result.success ? 200 : 400) });
    }

    // --- Group and Contact Management (Examples) ---
    if (mainAction === 'groups' && req.method === 'GET') { // List groups
        const result = await makeEvolutionRequest(evolutionConfig, `/group/fetchAllGroups/{instance}`);
        return new Response(JSON.stringify({data: result.data?.groups || result.data || {error: result.error}}), { headers, status: result.statusCode || (result.success ? 200 : 400) });
    }
    // Add POST to create group, GET /contacts, etc.

    return new Response(JSON.stringify({ error: "Rota do WhatsApp Manager não encontrada ou método não permitido." }), { status: 404, headers });
  } catch (error) {
    console.error("Erro na função WhatsApp Manager:", error.message, error.stack);
    const errorMessage = error instanceof ZodError ? fromZodError(error).message : error.message;
    return new Response(JSON.stringify({ error: errorMessage || "Erro interno do servidor." }), { status: 500, headers });
  }
});

/*
Environment Variables Needed:
- SUPABASE_URL
- SUPABASE_ANON_KEY
- SUPABASE_SERVICE_ROLE_KEY
- EVOLUTION_API_URL (optional, defaults in code)
- EVOLUTION_API_TOKEN (optional, defaults in code)
- EVOLUTION_API_INSTANCE (optional, defaults to 'default')
- WHATSAPP_WEBHOOK_VERIFY_TOKEN (for Meta webhook verification)

Database Tables:
- `leads` (id, name, phone)
- `whatsapp_messages` (id, leadId, direction, content, status, mediaUrl, mediaType, messageId, timestamp)
- `whatsapp_settings` (apiUrl, apiToken, apiInstance, updatedAt) - Stores Evolution API config
- `profiles` (id, role) - For checking admin role

Assumes an RPC function `get_recent_whatsapp_messages_per_lead` for `/recent-messages` endpoint.
If not available, that endpoint will return an empty object or error.
*/
