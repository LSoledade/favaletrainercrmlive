// Follow this setup guide to integrate the Deno language server with your editor:
// https://deno.land/manual/getting_started/setup_your_environment
// This enables autocomplete, go to definition, etc.

// Setup type definitions for built-in Supabase Runtime APIs
import "jsr:@supabase/functions-js/edge-runtime.d.ts"
import { createClient, SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { z } from "https://deno.land/x/zod@v3.23.4/mod.ts";

// --- Schemas Definition (Ideally from a shared location) ---
const leadStatusEnum = z.enum(["Lead", "Aluno", "Contato", "Oportunidade", "Cliente", "Ex-Aluno", "Perdido"]);
const leadSourceEnum = z.enum(["Favale", "Pink", "Website", "Referencia", "Campanha", "Outro"]);

const baseLeadSchema = z.object({
  name: z.string().min(1, "O nome é obrigatório."),
  email: z.string().email("Formato de e-mail inválido.").optional().nullable(),
  phone: z.string().min(8, "Telefone precisa ter no mínimo 8 dígitos.").optional().nullable(), // Normalize before validation
  state: z.string().optional().nullable(), // Could be an enum if states are predefined
  campaign: z.string().optional().nullable(),
  tags: z.array(z.string()).default([]).optional().nullable(),
  source: leadSourceEnum.default("Outro"),
  status: leadStatusEnum.default("Lead"),
  notes: z.string().optional().nullable(),
  entryDate: z.preprocess((arg) => {
    if (!arg) return new Date(); // Default to now if not provided
    if (typeof arg === "string") {
      if (/^\d{2}\/\d{2}\/\d{4}$/.test(arg)) { // DD/MM/YYYY
        const [day, month, year] = arg.split('/');
        return new Date(`${year}-${month}-${day}T00:00:00.000Z`);
      }
      const d = new Date(arg);
      return isNaN(d.getTime()) ? new Date() : d; // Default to now if parsing fails
    }
    if (arg instanceof Date) return arg;
    return new Date();
  }, z.date().transform(d => d.toISOString())), // Store as ISO string
});

const leadValidationSchema = baseLeadSchema.refine(data => data.email || data.phone, {
    message: "Pelo menos um e-mail ou telefone deve ser fornecido.",
    path: ["email"], // Path to display error, can be 'phone' or a general one
});

type InsertLead = z.infer<typeof leadValidationSchema>;
// Assuming 'id', 'createdAt', 'updatedAt' are auto-generated by DB
type Lead = InsertLead & { id: number; createdAt: string; updatedAt: string; };


const normalizePhone = (phone: string | undefined | null): string => {
  if (!phone) return '';
  return phone.replace(/\D/g, ''); // Removes all non-digits
};

// Ensure AuditEventType is defined or imported
enum AuditEventType {
  LEAD_CREATED = 'lead_created',
  LEAD_UPDATED = 'lead_updated',
  LEAD_DELETED = 'lead_deleted',
  LEAD_BATCH_IMPORT = 'lead_batch_import',
  LEAD_BATCH_UPDATE = 'lead_batch_update',
  LEAD_BATCH_DELETE = 'lead_batch_delete',
  // ... other event types
}

async function logAuditEvent(supabase: SupabaseClient, type: AuditEventType, userId: string, details: any = {}) {
  try {
    const { error } = await supabase.from('audit_logs').insert({
      type: type.toString(),
      user_id: userId,
      details,
    });
    if (error) console.error(`Audit log error for ${type.toString()}:`, error.message);
  } catch (e) {
    console.error(`Exception during audit logging for ${type.toString()}:`, e.message);
  }
}

// --- Supabase Client Initialization ---
const supabaseUrl = Deno.env.get('SUPABASE_URL');
const serviceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
const anonKey = Deno.env.get('SUPABASE_ANON_KEY');

if (!supabaseUrl || !serviceRoleKey || !anonKey) {
    console.error("Supabase URL, Service Role Key, or Anon Key is missing.");
}

// --- Request Handler ---
Deno.serve(async (req) => {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  };

  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  const headers = { 
    "Content-Type": "application/json",
    ...corsHeaders
  };
  if (!supabaseUrl || !serviceRoleKey || !anonKey) {
    return new Response(JSON.stringify({ error: "Configuração do servidor incompleta." }), { status: 503, headers });
  }

  const supabaseAdminClient = createClient(supabaseUrl, serviceRoleKey);
  const userSupabaseClient = createClient(supabaseUrl, anonKey, {
    global: { headers: { Authorization: req.headers.get('Authorization')! } }
  });

  const { data: { user } } = await userSupabaseClient.auth.getUser();
  if (!user) {
    return new Response(JSON.stringify({ error: "Não autenticado" }), { status: 401, headers });
  }

  const { pathname } = new URL(req.url);
  const pathParts = pathname.split('/').filter(part => part);
  const action = pathParts[3]; // e.g., 'batch', or lead_id for specific lead
  const subAction = pathParts[4]; // e.g., 'import', 'update', 'delete' for batch

  console.log("Lead Function Request:", req.method, pathname, "Action:", action, "SubAction:", subAction);

  try {
    // --- BATCH OPERATIONS ---
    if (req.method === 'POST' && action === 'batch') {
      const body = await req.json();

      if (subAction === 'import') {
        const { leads: leadsToImport } = body;
        if (!Array.isArray(leadsToImport) || leadsToImport.length === 0) {
          return new Response(JSON.stringify({ error: "Nenhum lead válido fornecido para importação." }), { status: 400, headers });
        }

        const results = { successfulImports: [] as Lead[], updatedLeads: [] as Lead[], errors: [] as any[] };
        const leadsToInsert: InsertLead[] = [];
        const leadsToUpdateOps: Array<{id: number, payload: Partial<InsertLead>}> = [];

        // Fetch existing leads by phone/email for deduplication (batched if necessary for large datasets)
        const phonesToQuery = leadsToImport.map(l => normalizePhone(l.phone)).filter(Boolean);
        const emailsToQuery = leadsToImport.map(l => l.email?.toLowerCase()).filter(Boolean);

        let existingLeadsByPhone = new Map<string, Lead>();
        let existingLeadsByEmail = new Map<string, Lead>();

        if (phonesToQuery.length > 0) {
            const { data: phoneData } = await supabaseAdminClient.from('leads').select<string, Lead>('*').in('phone', phonesToQuery);
            phoneData?.forEach(l => existingLeadsByPhone.set(normalizePhone(l.phone)!, l));
        }
        if (emailsToQuery.length > 0) {
            const { data: emailData } = await supabaseAdminClient.from('leads').select<string, Lead>('*').in('email', emailsToQuery);
            emailData?.forEach(l => existingLeadsByEmail.set(l.email!.toLowerCase(), l));
        }


        for (const leadData of leadsToImport) {
          const currentPhoneNormalized = normalizePhone(leadData.phone);
          const currentEmailLower = leadData.email?.toLowerCase();
          let existingLead: Lead | undefined = undefined;

          if (currentPhoneNormalized && existingLeadsByPhone.has(currentPhoneNormalized)) {
            existingLead = existingLeadsByPhone.get(currentPhoneNormalized);
          } else if (currentEmailLower && existingLeadsByEmail.has(currentEmailLower)) {
            existingLead = existingLeadsByEmail.get(currentEmailLower);
          }

          let processedTags = leadData.tags;
          if (typeof processedTags === 'string') {
            processedTags = processedTags.split(/[,;]/).map((tag: string) => tag.trim()).filter(Boolean);
          } else if (!Array.isArray(processedTags)) {
            processedTags = [];
          }
          const payload = { ...leadData, phone: currentPhoneNormalized, tags: processedTags };

          try {
            const validationResult = leadValidationSchema.parse(payload); // Full validation for new or to-be-updated
            if (existingLead) {
                // Update existing lead: merge tags, update other fields
                const combinedTags = Array.from(new Set([...(existingLead.tags || []), ...(validationResult.tags || [])])).filter(Boolean);
                leadsToUpdateOps.push({id: existingLead.id, payload: {...validationResult, tags: combinedTags} });
            } else {
                leadsToInsert.push(validationResult);
            }
          } catch (e) {
            results.errors.push({ error: e instanceof z.ZodError ? e.errors.map(err => `${err.path.join('.')}: ${err.message}`).join(', ') : e.message, data: leadData });
          }
        }

        if (leadsToInsert.length > 0) {
          const { data: inserted, error: insertError } = await supabaseAdminClient.from('leads').insert(leadsToInsert).select();
          if (insertError) results.errors.push({ error: `Erro na inserção em lote: ${insertError.message}` });
          else results.successfulImports.push(...(inserted as Lead[] || []));
        }
        for(const op of leadsToUpdateOps){
            const {data: updated, error: updateError} = await supabaseAdminClient.from('leads').update(op.payload).eq('id', op.id).select();
            if(updateError) results.errors.push({error: `Erro ao atualizar lead ${op.id}: ${updateError.message}`, data: op.payload});
            else results.updatedLeads.push(...(updated as Lead[] || []));
        }

        await logAuditEvent(supabaseAdminClient, AuditEventType.LEAD_BATCH_IMPORT, user.id, {
            totalAttempted: leadsToImport.length,
            successfulImports: results.successfulImports.length,
            updatedLeads: results.updatedLeads.length,
            errors: results.errors.length
        });
        return new Response(JSON.stringify({ data: results }), { status: 200, headers });
      }

      if (subAction === 'update') { // Batch update by IDs
        const { ids, updates } = body;
        if (!Array.isArray(ids) || ids.length === 0 || !updates || typeof updates !== 'object') {
          return new Response(JSON.stringify({ error: "IDs e payload de atualização são obrigatórios." }), { status: 400, headers });
        }
        const validationResult = leadValidationSchema.partial().safeParse(updates);
        if(!validationResult.success) return new Response(JSON.stringify({ error: "Dados de atualização inválidos.", details: validationResult.error.errors.map(err => `${err.path.join('.')}: ${err.message}`).join(', ') }), { status: 400, headers });

        const { data, error, count } = await supabaseAdminClient.from('leads').update(validationResult.data).in('id', ids).select();
        if (error) throw error;
        await logAuditEvent(supabaseAdminClient, AuditEventType.LEAD_BATCH_UPDATE, user.id, { leadIds: ids, updatedFields: Object.keys(validationResult.data), count });
        return new Response(JSON.stringify({ data: { updatedCount: count, updatedLeads: data } }), { status: 200, headers });
      }

      if (subAction === 'delete') { // Batch delete by IDs
        const { ids } = body;
        if (!Array.isArray(ids) || ids.length === 0) return new Response(JSON.stringify({ error: "IDs são obrigatórios para exclusão em lote." }), { status: 400, headers });

        // Consider RLS if not using admin client or if specific users can delete specific leads.
        // Handle related data (e.g., whatsapp_messages) if not using DB cascades.
        await supabaseAdminClient.from('whatsapp_messages').delete().in('leadId', ids); // Example for related data

        const { error, count } = await supabaseAdminClient.from('leads').delete({ count: 'exact' }).in('id', ids);
        if (error) throw error;
        await logAuditEvent(supabaseAdminClient, AuditEventType.LEAD_BATCH_DELETE, user.id, { leadIds: ids, count });
        return new Response(JSON.stringify({ data: { deletedCount: count } }), { status: 200, headers });
      }
    }

    // --- STANDARD CRUD OPERATIONS ---
    // GET all leads (with pagination and filtering)
    if (req.method === 'GET' && !action) {
      const url = new URL(req.url);
      const page = parseInt(url.searchParams.get('page') || '1');
      const limit = parseInt(url.searchParams.get('limit') || '25');
      const offset = (page - 1) * limit;
      // Add more filters as needed (e.g., status, source, search term)
      const { data, error, count } = await supabaseAdminClient.from('leads').select('*', {count: 'exact'}).range(offset, offset + limit -1);
      if (error) throw error;
      return new Response(JSON.stringify({ data, meta: { total: count, page, limit } }), { status: 200, headers });
    }

    // POST create lead
    if (req.method === 'POST' && !action) {
      const body = await req.json();
      const payload = { ...body, phone: normalizePhone(body.phone) };
      const validationResult = leadValidationSchema.safeParse(payload);
      if (!validationResult.success) {
        return new Response(JSON.stringify({ error: "Dados de lead inválidos.", details: validationResult.error.errors.map(err => `${err.path.join('.')}: ${err.message}`).join(', ') }), { status: 400, headers });
      }
      const { data: newLead, error } = await supabaseAdminClient.from('leads').insert(validationResult.data).select().single();
      if (error) throw error;
      await logAuditEvent(supabaseAdminClient, AuditEventType.LEAD_CREATED, user.id, { leadId: newLead.id, name: newLead.name });
      return new Response(JSON.stringify({ data: newLead }), { status: 201, headers });
    }

    const leadIdParam = action;
    if (leadIdParam && !isNaN(parseInt(leadIdParam))) {
      const leadId = parseInt(leadIdParam);

      // GET lead by ID
      if (req.method === 'GET') {
        const { data, error } = await supabaseAdminClient.from('leads').select<string, Lead>('*').eq('id', leadId).single();
        if (error) {
            if (error.code === 'PGRST116') return new Response(JSON.stringify({ error: "Lead não encontrado." }), { status: 404, headers });
            throw error;
        }
        return new Response(JSON.stringify({ data }), { status: 200, headers });
      }

      // PATCH update lead
      if (req.method === 'PATCH') {
        const body = await req.json();
        const payload = body.phone ? { ...body, phone: normalizePhone(body.phone) } : body;
        const validationResult = leadValidationSchema.partial().safeParse(payload);
        if (!validationResult.success) {
          return new Response(JSON.stringify({ error: "Dados de atualização de lead inválidos.", details: validationResult.error.errors.map(err => `${err.path.join('.')}: ${err.message}`).join(', ') }), { status: 400, headers });
        }
        const { data: updatedLead, error } = await supabaseAdminClient.from('leads').update(validationResult.data).eq('id', leadId).select().single();
        if (error) {
            if (error.code === 'PGRST116') return new Response(JSON.stringify({ error: "Lead não encontrado para atualizar." }), { status: 404, headers });
            throw error;
        }
        await logAuditEvent(supabaseAdminClient, AuditEventType.LEAD_UPDATED, user.id, { leadId: updatedLead.id, updatedFields: Object.keys(validationResult.data) });
        return new Response(JSON.stringify({ data: updatedLead }), { status: 200, headers });
      }

      // DELETE lead
      if (req.method === 'DELETE') {
        // Ensure user has permission (e.g., admin or owner) if not using service_role for all deletes.
        // Handle related data (e.g., whatsapp_messages) if not using DB cascades.
        await supabaseAdminClient.from('whatsapp_messages').delete().eq('leadId', leadId); // Example

        const { error, count } = await supabaseAdminClient.from('leads').delete({ count: 'exact' }).eq('id', leadId);
        if (error) throw error;
        if (count === 0) return new Response(JSON.stringify({ error: "Lead não encontrado para deletar." }), { status: 404, headers });
        await logAuditEvent(supabaseAdminClient, AuditEventType.LEAD_DELETED, user.id, { leadId });
        return new Response(null, { status: 204, headers }); // No content for successful delete
      }
    }

    return new Response(JSON.stringify({ error: "Rota de lead não encontrada ou método não permitido." }), { status: 404, headers });

  } catch (error) {
    console.error('Erro na função Lead:', error.message, error.stack);
    const errorMessage = error instanceof z.ZodError ? error.errors.map(err => `${err.path.join('.')}: ${err.message}`).join(', ') : error.message;
    return new Response(JSON.stringify({ error: errorMessage || "Erro interno do servidor." }), { status: 500, headers });
  }
});

/*
To invoke locally:
Supabase CLI handles routing based on function name.

1. Start Supabase: `supabase start`
2. Invoke (examples):

   GET all leads:
   curl -i --location --request GET 'http://127.0.0.1:54321/functions/v1/lead-functions' \
     --header 'Authorization: Bearer YOUR_USER_JWT_OR_ANON_KEY'

   POST create lead:
   curl -i --location --request POST 'http://127.0.0.1:54321/functions/v1/lead-functions' \
     --header 'Authorization: Bearer YOUR_USER_JWT_OR_ANON_KEY' \
     --header 'Content-Type: application/json' \
     --data '{"name":"Test Lead", "email":"test@example.com", "phone":"123456789", "state":"CA", "campaign":"Test Campaign", "tags":["hot"], "source":"Website", "status":"New", "entryDate": "2023-01-01"}'

   GET lead by ID (e.g., ID 1):
   curl -i --location --request GET 'http://127.0.0.1:54321/functions/v1/lead-functions/1' \
     --header 'Authorization: Bearer YOUR_USER_JWT_OR_ANON_KEY'

   PATCH update lead (e.g., ID 1):
   curl -i --location --request PATCH 'http://127.0.0.1:54321/functions/v1/lead-functions/1' \
     --header 'Authorization: Bearer YOUR_USER_JWT_OR_ANON_KEY' \
     --header 'Content-Type: application/json' \
     --data '{"status":"Contacted"}'

   DELETE lead (e.g., ID 1):
   curl -i --location --request DELETE 'http://127.0.0.1:54321/functions/v1/lead-functions/1' \
     --header 'Authorization: Bearer YOUR_USER_JWT_OR_ANON_KEY'

   POST batch import:
   curl -i --location --request POST 'http://127.0.0.1:54321/functions/v1/lead-functions/batch/import' \
     --header 'Authorization: Bearer YOUR_USER_JWT_OR_ANON_KEY' \
     --header 'Content-Type: application/json' \
     --data '{"leads": [{"name":"Batch Lead 1", ...}, {"name":"Batch Lead 2", ...}]}'

   POST batch update:
   curl -i --location --request POST 'http://127.0.0.1:54321/functions/v1/lead-functions/batch/update' \
     --header 'Authorization: Bearer YOUR_USER_JWT_OR_ANON_KEY' \
     --header 'Content-Type: application/json' \
     --data '{"ids": [1, 2], "updates": {"status": "Archived"}}'

   POST batch delete:
   curl -i --location --request POST 'http://127.0.0.1:54321/functions/v1/lead-functions/batch/delete' \
     --header 'Authorization: Bearer YOUR_USER_JWT_OR_ANON_KEY' \
     --header 'Content-Type: application/json' \
     --data '{"ids": [1, 2]}'
*/
