// Follow this setup guide to integrate the Deno language server with your editor:
// https://deno.land/manual/getting_started/setup_your_environment
// This enables autocomplete, go to definition, etc.

import "jsr:@supabase/functions-js/edge-runtime.d.ts"
import { createClient, SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { OAuth2Client } from 'https://deno.land/x/oauth2_client@v1.0.2/mod.ts'; // Deno OAuth2 client

// --- Supabase Clients & Env Vars ---
const supabaseUrl = Deno.env.get('SUPABASE_URL');
const supabaseAnonKey = Deno.env.get('SUPABASE_ANON_KEY');
const serviceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
const googleClientId = Deno.env.get('GOOGLE_CLIENT_ID');
const googleClientSecret = Deno.env.get('GOOGLE_CLIENT_SECRET');
const clientAppUrl = Deno.env.get('CLIENT_URL'); // URL of your frontend app for postMessage

if (!supabaseUrl || !supabaseAnonKey || !serviceRoleKey || !googleClientId || !googleClientSecret || !clientAppUrl) {
    console.error("One or more critical environment variables for Google OAuth are missing.");
    // This function might not work correctly if these are not set.
}

// IMPORTANT: This redirect URI must be registered in your Google Cloud Console
// and must point to THIS Edge Function.
// Example: https://<project-ref>.supabase.co/functions/v1/google-oauth/callback
const GOOGLE_REDIRECT_URI = `${supabaseUrl}/functions/v1/google-oauth/callback`;

let oauth2Client: OAuth2Client | null = null;
if (googleClientId && googleClientSecret) {
    oauth2Client = new OAuth2Client({
        clientId: googleClientId,
        clientSecret: googleClientSecret,
        authorizationEndpointUri: "https://accounts.google.com/o/oauth2/v2/auth",
        tokenUri: "https://oauth2.googleapis.com/token",
        redirectUri: GOOGLE_REDIRECT_URI,
        defaults: {
            scope: [
                "https://www.googleapis.com/auth/userinfo.email", // Basic profile info
                "https://www.googleapis.com/auth/userinfo.profile",
                "https://www.googleapis.com/auth/calendar",       // Full access to calendars
                "https://www.googleapis.com/auth/calendar.events" // Full access to events
                // Add other scopes as needed, e.g., for Google Sheets, Drive, etc.
            ],
        },
    });
}


// --- Audit Log Helper (Simplified) ---
// Ensure AuditEventType is defined and accessible, or replicate definition
enum AuditEventType {
  OAUTH_INIT = 'oauth_init',
  OAUTH_SUCCESS = 'oauth_success',
  OAUTH_ERROR = 'oauth_error',
  OAUTH_REVOKE = 'oauth_revoke'
  // ... other event types
}

async function logAuditEvent(supabase: SupabaseClient, type: AuditEventType, userId: string | null, details: any = {}) {
  if (!userId) {
    console.warn("Cannot log audit event without user ID for OAuth operation:", type);
    return;
  }
  try {
    // Ensure 'audit_logs' table exists with 'type', 'user_id', and 'details' columns.
    // 'user_id' should match the type of your auth.users.id (usually uuid).
    const { error } = await supabase.from('audit_logs').insert({
        type: type.toString(), // Ensure it's a string if enum is used
        user_id: userId,
        details: { provider: 'google', ...details },
        // timestamp is usually auto-generated by DB (e.g. with default now())
    });
    if (error) console.error("Audit log error for Google OAuth:", error.message);
  } catch (e) {
    console.error("Exception during audit logging for Google OAuth:", e.message);
  }
}

// --- Main Handler ---
Deno.serve(async (req) => {
  const headers = { "Content-Type": "application/json" };

  if (!oauth2Client) {
    return new Response(JSON.stringify({ error: "Configuração do Google OAuth no servidor está incompleta." }), { status: 503, headers });
  }

  const userSupabaseClient = createClient(supabaseUrl!, supabaseAnonKey!, {
    global: { headers: { Authorization: req.headers.get('Authorization')! } }
  });
  const adminSupabaseClient = createClient(supabaseUrl!, serviceRoleKey!);

  const { data: { user }, error: userError } = await userSupabaseClient.auth.getUser();

  // User must be authenticated for all actions except the callback, which might be initiated by Google.
  // However, even for callback, we link tokens to the user who initiated the flow.
  // For simplicity, we require authentication for all paths here.
  // A more complex setup might store a temporary state to link callback to pre-auth user.
  if (userError || !user) {
    return new Response(JSON.stringify({ error: "Não autenticado" }), { status: 401, headers });
  }

  const url = new URL(req.url);
  const action = url.pathname.split('/').pop(); // e.g., 'auth-url', 'callback', 'status', 'revoke'

  console.log(`Google OAuth Action: ${action}, User ID: ${user.id}`);

  try {
    if (req.method === 'GET' && action === 'auth-url') {
      // 'state' parameter can be used to prevent CSRF and pass custom data.
      // const state = crypto.randomUUID(); // Generate a random state
      // Store state with user.id if needed for validation on callback, or pass through.

      const authUri = await oauth2Client.code.getAuthorizationUri({
         // state: state, // Include state if using it
      });
      // Ensure 'access_type: offline' for refresh token and 'prompt: consent' to ensure user sees consent screen
      const finalAuthUrl = new URL(authUri.toString());
      finalAuthUrl.searchParams.set('access_type', 'offline');
      finalAuthUrl.searchParams.set('prompt', 'consent'); // Forces consent screen, good for ensuring refresh token

      await logAuditEvent(adminSupabaseClient, AuditEventType.OAUTH_INIT, user.id);
      return new Response(JSON.stringify({ data: { authUrl: finalAuthUrl.toString() } }), { headers, status: 200 });
    }

    if (req.method === 'GET' && action === 'callback') {
      const code = url.searchParams.get('code');
      const errorParam = url.searchParams.get('error');
      // const stateParam = url.searchParams.get('state'); // Validate state if used

      if (errorParam) {
        await logAuditEvent(adminSupabaseClient, AuditEventType.OAUTH_ERROR, user.id, { error: errorParam, step: 'callback_param' });
        // Redirect to a frontend page that displays the error, or postMessage
        return new Response(
          `<script>window.opener && window.opener.postMessage({type: 'oauthError', provider: 'google', error: '${errorParam}'}, '${clientAppUrl}'); window.close();</script>`,
          { headers: { "Content-Type": "text/html" } }
        );
      }
      if (!code) {
        await logAuditEvent(adminSupabaseClient, AuditEventType.OAUTH_ERROR, user.id, { error: 'Código de autorização ausente', step: 'callback_code' });
        return new Response(JSON.stringify({ error: 'Código de autorização não fornecido na callback.' }), { status: 400, headers });
      }

      const tokens = await oauth2Client.code.getToken(url); // The library handles parsing 'code' from the URL

      // Store tokens securely, associating them with the user.id
      // Table 'google_tokens' schema: user_id (FK to auth.users.id), access_token, refresh_token (nullable), expiry_date, updated_at
      const { error: saveError } = await adminSupabaseClient.from('google_tokens').upsert({
        user_id: user.id, // Ensure this column name matches your table (user_id vs userId)
        access_token: tokens.accessToken,
        refresh_token: tokens.refreshToken, // This might be null if not granted or user already granted
        expiry_date: tokens.expiresIn ? new Date(Date.now() + tokens.expiresIn * 1000).toISOString() : null,
        updated_at: new Date().toISOString(),
      }, { onConflict: 'user_id' }); // Upsert based on user_id

      if (saveError) {
        await logAuditEvent(adminSupabaseClient, AuditEventType.OAUTH_ERROR, user.id, { error: saveError.message, step: 'token_save' });
        throw saveError; // Propagate to main catch block
      }

      await logAuditEvent(adminSupabaseClient, AuditEventType.OAUTH_SUCCESS, user.id, { hasRefreshToken: !!tokens.refreshToken });
      // Post message to parent window and close popup
      return new Response(
        `<script>window.opener && window.opener.postMessage({type: 'oauthSuccess', provider: 'google'}, '${clientAppUrl}'); window.close();</script>`,
        { headers: { "Content-Type": "text/html" } }
      );
    }

    if (req.method === 'GET' && action === 'status') {
      const { data: tokenData, error: tokenError } = await adminSupabaseClient
        .from('google_tokens')
        .select('access_token, refresh_token, expiry_date') // Ensure column names match DB
        .eq('user_id', user.id) // Ensure column name matches DB
        .single();

      if (tokenError && tokenError.code !== 'PGRST116') throw tokenError; // PGRST116: single row not found
      if (!tokenData) {
        return new Response(JSON.stringify({ data: { authorized: false, message: 'Nenhuma autorização do Google encontrada para este usuário.' } }), { headers, status: 200 });
      }

      const isExpired = tokenData.expiry_date ? new Date(tokenData.expiry_date).getTime() <= Date.now() : true;
      return new Response(JSON.stringify({
        data: {
            authorized: true,
            isExpired,
            hasRefreshToken: !!tokenData.refresh_token,
            expiryDate: tokenData.expiry_date ? new Date(tokenData.expiry_date).toISOString() : null,
        }
      }), { headers, status: 200 });
    }

    if (req.method === 'DELETE' && action === 'revoke') {
      // Optionally, attempt to revoke the token with Google first
      // const { data: tokenInfo } = await adminSupabaseClient.from('google_tokens').select('access_token, refresh_token').eq('user_id', user.id).single();
      // if (tokenInfo?.access_token) {
      //    try {
      //      await oauth2Client.revoke(tokenInfo.access_token, { tokenTypeHint: "access_token" });
      //      if(tokenInfo.refresh_token) await oauth2Client.revoke(tokenInfo.refresh_token, { tokenTypeHint: "refresh_token" });
      //    } catch (revokeErr) { console.warn("Failed to revoke Google token directly:", revokeErr.message); }
      // }

      const { error: deleteError } = await adminSupabaseClient
        .from('google_tokens')
        .delete()
        .eq('user_id', user.id); // Ensure column name matches DB

      if (deleteError) throw deleteError;

      await logAuditEvent(adminSupabaseClient, AuditEventType.OAUTH_REVOKE, user.id);
      return new Response(JSON.stringify({ data: { message: 'Acesso do Google revogado com sucesso.' } }), { headers, status: 200 });
    }

    return new Response(JSON.stringify({ error: "Ação OAuth não encontrada ou método não permitido." }), { status: 404, headers });

  } catch (error) {
    console.error('Erro na função Google OAuth:', error.message, error.stack);
    // Ensure user.id is available for logging, might be null if error happened before user retrieval
    await logAuditEvent(adminSupabaseClient, AuditEventType.OAUTH_ERROR, user ? user.id : null, { error: error.message, stack: error.stack, action });
    return new Response(JSON.stringify({ error: error.message || "Erro interno do servidor OAuth." }), { status: 500, headers });
  }
});

/*
Deployment and Setup:
1. Ensure GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET are set as environment variables for this Edge Function in Supabase dashboard.
2. The GOOGLE_REDIRECT_URI (e.g., https://<project-ref>.supabase.co/functions/v1/google-oauth/callback) MUST be added to your
   Google Cloud Console project under "Authorized redirect URIs" for your OAuth 2.0 Client ID.
3. The `google_tokens` table must exist in your Supabase database with columns like:
   - userId (text or uuid, primary key / unique, references auth.users.id)
   - accessToken (text)
   - refreshToken (text, nullable)
   - expiryDate (timestamp with time zone, nullable)
   - updatedAt (timestamp with time zone)

Invocation Examples (after deploying and setting up Supabase local dev or production):

Get Auth URL:
curl -i --location --request GET 'http://127.0.0.1:54321/functions/v1/google-oauth/auth-url' \
  --header 'Authorization: Bearer YOUR_USER_JWT'

Callback URL: (This is typically opened by the browser after Google authentication)
http://127.0.0.1:54321/functions/v1/google-oauth/callback?code=AUTH_CODE_FROM_GOOGLE

Get Token Status:
curl -i --location --request GET 'http://127.0.0.1:54321/functions/v1/google-oauth/status' \
  --header 'Authorization: Bearer YOUR_USER_JWT'

Revoke Access:
curl -i --location --request DELETE 'http://127.0.0.1:54321/functions/v1/google-oauth/revoke' \
  --header 'Authorization: Bearer YOUR_USER_JWT'
*/
